### 아키텍쳐 패턴
- 레이어패턴
- 클라이언트-서버패턴
- 파이프-필터패턴 
   - 데이터 스트림 절차의 각 단계를 필터로 캡슐화하여 파이프를 통해 전송하는 패턴
   - 데이터 변환, 버퍼링, 동기화 등에 주로 사용됨
   - ex) UNIX 쉘
- MVC 패턴
   - 서브시스템을 모델-뷰-컨트롤러로 구조화
   - 컨트롤러가 사용자의 요청을 받으면 핵심 기능과 데이터를 보관하는 모델을 이용하여 뷰에 정보를 출력
   - 한개의 모델에 대해 여러개의 뷰를 필요로하는 대화형 애플리케이션에 적합

#### 기타패턴
- 마스터 슬래이브 패턴 : 슬레이브 컴포넌트에서 처리된 결과물을 다시 돌려받는 방식으로 작업 수행 
   - ex) 장애허용시스템, 병렬 컴퓨팅 시스템
- 브로커 패턴 : 사용자가 원하는 서비스와 특성을 브로커 컴포넌트에 요청하면 브로커 컴포넌트가 요청에 맞는 컴포넌트와 사용자를 연결해주는 패턴
   - ex) 분산 환경 시스템


## 디자인패턴
생성 패턴(Creational Pattern)
'캡슐화'하여 프로그램의 '구조에 영향을 받지 않도록' 하여 '유연성'을 더해준다.

1. 추상 팩토리(Abstract Factory) - 서로 다른 부품을 조립만 하는 조립공장
서로 연관, 의존하는 객체들의 그룹으로 생성하여 추상적으로 표현.
연관된 서브 클래스를 묶어 한 번에 교체 가능.

2. 빌더(Builder) - 건축가가 블록을 조립하는 모습
분리된 인스턴스(객체)를 건축하듯이 조합하여 객체를 생성.
동일한 객체 생성에서도 다른 결과 나올 수 있음.

3. 팩토리 메소드(Factory Method) - 부품부터 완성품까지 통째로 찍어내는 공장
상위 클래스에서 인터페이스만 정의, 실제 생성은 서브 클래스가 담당.

4. 프로토타입(Prototype) - 원형을 두고 복제품을 만드는 것
원본 객체를 복제하는 방법.
비용이 큰 경우 주로 이용.

5. 싱글톤(Singleton) - 식당에서 누구나 사용하지만 하나뿐인 정수기
객체를 어디서든 참조할 수 있지만, 여러 프로세스가 동시에 참조하는 것은 불가능.
인스턴스가 하나뿐이기 때문에 불필요한 메모리 낭비를 최소화 할 수 있음.
구조 패턴(Structural Pattern)

구조가 복잡한 시스템을 개발하기 쉽도록 도와준다.

1. 어댑터(Adaptor) - 호환성을 맞춰주는 변압기
클래스들의 호환성이 맞도록 변환해주는 패턴.
기존의 클래스를 이용하고 싶은데 인터페이스가 일치하지 않을 때 사용.

2. 브리지(Bridge) - 두 섬을 연결하는 다리
서로가 독립적으로 확장할 수 있도록 구성한 패턴.
기능과 구현을 별도의 클래스에서 구현.

3. 컴포지트(Composite) - 폴더와 파일을 합성한 것
복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용.
복합 객체 안에 복합 객체가 포함되는 구조 구현 가능.(폴더 안의 폴더)

4. 데코레이터(Decorator) - 온갖 것으로 장식된 눈사람
객체 간의 결합으로 기능을 확장할 수 있음.
부가적인 기능 추가를 위해 다른 객체들을 덧붙이는 방식.

5. 퍼싸드(Facade) - 리모컨만으로 복잡한 명령을 수행하는 것
상위에 인터페이스를 구성하여 서브 클래스들의 기능을 수행할 수 있음.
서브 클래스들 사이의 통합 인터페이스를 제공하는 Wrapper 객체 필요.

6. 플라이웨이트(Flyweight) - 부담을 가볍게 하기 위해 물품 공유
인스턴스를 가능한 공유해서 사용하여 메모리를 절약.
다수의 유사 객체를 생성하거나 조작할 때 유용함.

7. 프록시(Proxy) - 하기 어려운 업무를 대리로 해주는 사람
접근이 어려운 객체와 여기 접근하려는 객체 사이의 인터페이스 역할.
네트워크 연결, 메모리의 대용량 객체로의 접근에 이용.
행위 패턴(Behavioral Pattern)

하나의 객체로 수행할 수 없는 작업을 여러 객체로 분배하여 결합도를 최소화 하도록 도와준다.

1. 책임 연쇄(Chain of Responsibility) - 연속해서 나눠받는 물레방아
한 객체가 처리하지 못하면 다음 객체로 넘어가는 패턴.
요청이 해결될 때까지 고리를 따라 책임이 넘어감.

2. 커맨드(Command) - 명령어를 하나로 합쳐둔 것
요청을 캡슐화하여 재이용하거나 취소할 수 있도록 저장하거나 로그로 남김.
추상클래스와 구체클래스로 나뉨.

3. 인터프리터(Interpreter) - 언어 번역가
언어에 문법 표현을 정의함.
SQL이나 통신 프로토콜에 사용.

4. 반복자(Iterator) - 같은 명령의 반복
접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 함.
내부 표현 방법의 노출 없이 순차적인 접근 가능.

5. 중재자(Mediator) - 매매를 중개해주는 중개사이트
객체들 간의 복잡한 상호작용을 캡슐화하여 객체로 정의.
객체 사이의 결합도를 감소시킴.

6. 메멘토(Memento) - 기억 속의 그 때로 돌아감.
객체를 특정 시점의 상태로 돌릴 수 있는 기능.
ctrl+z 와 같은 기능 개발시 사용.

7. 옵서버(Observer) - 변화를 지켜보고 알려주는 것
한 객체의 상태 변화시 상속되어 있는 다른 객체들에게 알림.
시스템간에 이벤트를 생성하고 수신할 때 사용.

8. 상태(State) - 상태에 따라 다른 방법을 사용함
객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용.
객체 상태를 캡슐화하고 이를 참조함.

9. 전략(Strategy) - 여러 전략을 정하고 필요할 때 선택하여 씀
동일한 계열의 알고리즘을 캡슐화하여 상호 교환할 수 있게 정의함.
원하는 알고리즘을 선택하여 사용하며 클라이언트에 영향 없이 알고리즘 변경 가능

10. 템플릿 메소드(Template Method) - 방법들을 큰 틀로 묶는 것
상위 클래스에서 골격 정의, 하위 클래스에서 세부 처리를 구체화.
유사한 서브 클래스의 공통된 내용을 상위 클래스에서 정의. (유지보수 용이하게 함)

11. 방문자(Visitor) - 책을 만들기 위해 저자, 편집자를 번갈아가며 방문
각 클래스들의 데이터 구조에서 처리 기능을 별도의 클래스로 구성.
분리된 기능은 각 클래스를 방문하여 수행.
