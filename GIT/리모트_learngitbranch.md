# learn git branch 리모트 파트 

- 여기 다시봐야함 ^0^ 일단 복붙해놈

## 0. Remote Introduction
- 클라우드 컴퓨팅을 떠올리면 git remote의 이면에 수많은 마법이 부려지고 있을 것 같지만, 사실 git remote 또 하나의 컴퓨터에 있는 여러분의 저장소의 복사본일 뿐이다.
- 일반적으로 인터넷을 통해서 이 또 하나의 컴퓨터와 커밋을 주고받는 등의 대화를 할 수 있다.
- 원격저장소 장점
  - 1) 원격 저장소는 백업으로서의 역할을 훌륭하게 수행함
    - 로컬 git 저장소는 파일들을 이전의 상태로 되돌리는 기능을 가지고 있음
    - 하지만 그 모든 정보가 로컬(내 PC)에 저장되어 있음
    - git 저장소를 다른 컴퓨터가 복사본으로 가지고 있으면 로컬 데이터를 다 잃더라도 다른 컴퓨터에 남아있는 복사본으로 다시 출발 할 수 있음
  - 2) 원격 저장소를 통해 코딩을 다른 사람들과 함께 할 수 있다. 
    - 프로젝트의 복사본이 어느 곳에선가 호스트되기 때문에 여러분의 친구가 프로젝트에 아주 쉽게 기여할 수 있게 됨(최근의 변화를 pull하거나)
 - 원격 저장소에서의 활동을 시각화해주는 웹 사이트들을 사용하는 것이 추세 (GitHub 또는 Phabricator등이 있다)


# 1.1 Clone Intro
- git clone은 원격 저장소의 복사본을 _로컬_에 생성할때 사용하는 명령어
- Git 브랜치 배우기에서는 이 명령어를 살짝 다르게 사용
- git clone이 로컬 저장소에서 원격 저장소를 생성해냄
- 물론 실제 명령어와 반대로 작동하는 것이지만 클론과 원격 저장소 사이의 연결관계를 이해하는데 도움이되서 이렇게 함

```
git clone //원격 저장소를 가지게 됨. 구분을 하기위해 조금 모양이 다른것 말고는 둘이 똑같게 생긴걸 알 수 있다.
```

# 1.2 Remote Branches
- git clone 후의 변화 : 로컬 저장소에 o/master라고하는 새 브랜치가 생김 (이런 종류의 브랜치는 _원격_브랜치라고 불림)
- 원격 브랜치는 특정한 목적을 제공하기 때문에 특별한 속성들이 있다.
   - 원격 브랜치는 원격 저장소의 _상태_를 반영함(가장 최근 원격 원격저장소와 작업을 했을때를 기준으로). 
   - 원격 브랜치는 로컬에서의 작업과 공개적으로 되고있는 작업의 차이를 이해하는데 도와줌
   - 원격 브랜치는 체크 아웃을 하게 되면 분리된 HEAD 모드로 가게되는 특별한 속성이 있다.
   - Git은 이 브랜치들에서 직접 작업할 수 없기 때문에 일부로 이렇게 함
   - 우리는 다른곳에 작업을 하고 원격 저장소와 우리의 작업을 공유해야함(그 이후에 원격 브랜치가 갱신됨)

- o/ 란?
  - 원격 브랜치 또한 (필수적인) 이름짓기 규약이 있다
```
<remote name>/<branch name>
```
   - 이런 이유로, 만약 o/master라는 이름의 브랜치를 보게되면, 브랜치의 이름은 master이고 원격 저장소의 이름은 o인 것임
   - 대부분의 개발자들은 자신의 주 원격 저장소를 o가 아닌 origin이라고 지음
   - 사실 보통 다 이렇게 쓰기 때문에 git은 저장소를 git clone하게 되면 원격 저장소의 이름을 origin이라고 자동으로 설정해놓음
   - 부득이하게도 origin이라는 풀네임은 우리 UI에 안 맞아서 o로 간략히 표현:( 진짜 git을 사용하게되면 원격저장소가 아마 origin이라고 되있을 것임)

```
git commit
git checkout o/master
git commit
// git은 우리를 분리된 HEAD 모드로 만들고 새로운 커밋을 추가해도 o/master를 갱신하지 않는다. 이것은 o/master가 원격 저장소가 갱신될때만 갱신되기 때문이다.
// 원격 브랜치는 원격 저장소의 상태를 반영하기만 한다
```

# 1.3 Git Fetchin’
- git 원격 작업들은 결국 서로다른 저장소에서 데이터를 주고 _받는_것에 불과하다는것을 알 수 있다.
- 우리가 커밋들을 주고 받을수 있는 한, git을 바탕으로하는 모든 종류의 업데이트를 공유할 수 있다(작업, 새로운 파일들, 새로운 아이디어, 러브레터 등...).
- 여기서는 원격 저장소에서 데이터를 가져오는 방법을 배워볼 것임! -- 이를 위한 명령어는 git fetch라고 함
- 먼저 알아두고 넘어갈것이 있는데 우리가 원격 저장소와 작업을 해서 상태가 변하면 _원격_브랜치들 또한 그 변경들을 반영한다.

- git fetch는 두가지 단계
  - 원격 저장소에는 있지만 로컬에는 없는 커밋들을 다운로드 받는다.
  - 그리고 우리의 원격 브랜치가 가리키는곳을 업데이트함 (예를들어, o/master)

- git fetch는 본질적으로 로컬_에서 나타내는 원격 저장소의 상태를 _실제 원격 저장소의 (지금)상태와 동기화한다.
- 원격 브랜치는 가장 최근 원격 원격저장소와 작업을 했을때를 기준으로 원격 저장소의 상태를 반영한다고 했습니다. git fetch가 그러한 작업중에 하나입니다!(역: 
원문에서는 talk with remote라고 표현함. 원격 저장소와 대화한다고 번역하기 어색해서 의역했습니다.) 
- git fetch는 일반적으로 원격 저장소와 인터넷을 통해 접근합니다(http:// 또는 git://와같은 프로토콜로).

- git fetch는 그러나, 우리의 로컬 상태는 전혀 바꾸지 않는다. 우리의 master 브랜치도 업데이트하지 않고 파일 시스템의 모습이던 그 어떤것도 바꾸지 않는다.
- 앞의 과정에 필요한 데이터를 다운로드는 하지만, 실제로 로컬 파일들이나 브랜치를 변경하지는 않는다 (= 다운로드 단계라고 생각하면 됨)

```
git fetch
//  커밋 C2 와 C3가 우리의 로컬 저장소로 다운로드 되었고, 원격 브랜치 o/master가 이것을 반영하기 위해 업데이트 되었다.
```


# 1.4 Git Pullin’
- 이제 우리의 작업을 업데이트해서 변경들을 반영해봅시다
- 사실 이걸 하는 방법은 여러가지 있습니다 -- 새 커밋들을 로컬에 내려받은 이후에는 그냥 다른 브랜치에있는 일반 커밋처럼 활용할 수 있습니다. 이런 명령들을 실행할 수 있다는 뜻 입니다 :
   - 1) git cherry-pick o/master
   - 2)git rebase o/master
   - 3_ git merge o/master
   - 4_ 기타 등등
- 사실 원격 저장소의 변경을 fetch하고 그이후에 merge하는 작업의 과정이 워낙 자주있는 일이라서 git은 이 두가지를 한번에 하는 명령을 제공합니다! 이 명령어는 git pull 입니다.

```
git fetch; git merge o/master
//Boom -- 우리는 C3를 fetch로 내려 받고 git merge o/master로 우리의 작업으로 병합했습니다. 이제 우리의 master 브랜치는 원격 저장소의 새 작업들을 반영하게 됩니다(지금 사례에서 origin입니다).
```

대신에 git pull을 사용하면?
```
git pull
// 똑같은 일이 일이납니다! 이렇게 git pull은 본질적으로 git fetch후에 내려받은 브랜치를 병합하는 과정의 단축입니다.
```

# 1.5 Fakeing Teamwork
- 조금 곤란한일이 생겨버렸습니다 -- 앞으로 배울 레슨들에서 원격 저장소에서 일어난 변경들을 어떻게 로컬로 가져올것인지에 대해 배워 볼것입입니다.

- 그런데 여기서 우리는 불가피하게 그 _변경_들을 만들어야 되는데, 원격 저장소가 동료 / 친구 / 협력자등에 의해 특정 브랜치나 여러개의 커밋이 갱신되는 경우를 표현할 필요가 있습니다. 즉 우리는 팀워크를 "가장"할 필요가 있는것 입니다.

- 이런 문제를 해결하기 위해서 git fakeTeamwork 명령을 만들었습니다! 이름이 참 적절하죠? 예시를 통해 확인해봅시다...

- fakeTeamwork의 기본 행동은 원격 master에 간단히 하나의 커밋을 하는것 입니다.

```
// 명령어에 추가할 커밋의 갯수나 어떤 브랜치에 추가할지 지정하는것도 가능합니다. 다음과 같이 명령어 뒤에 추가하면 됩니다.
git fakeTeamwork 
// 자 됐습니다 -- 원격 저장소에 새로운 커밋이 갱신되었습니다. 아직 git fetch를 하지 않았기 때문에 로컬로 내려받아지지는 않았습니다.
git fakeTeamwork foo3
// 하나의 명령어로 팀원이 원격저장소의 foo 브랜치에 세개의 커밋을 push한것처럼 가장했습니다.
```

```
// 원격 저장소를 하나 만들고(git clone), 원격 저장소에 몇가지 가짜 변경을 만들고 로컬에서 커밋하고 원격의 변경들을 가져오세요. Goal과 같은 결과가 나오면 됩니다. 몇개의 레슨이 하나에 있다고 보면 되겠네요!.
git clone
git fakeTeamwork master 2
git commit
git pull
```

# 1.6 Git Pushin
- 좋은데 이제 나의 훌륭한 작업을 다른 사람들과 공유하려면 어떻게 해야되는거죠?
- 공유된 작업을 내려받는것의 반대는 작업을 업로드해 공유하는것입니다. 그렇다면 git pull 당기기의 반대는? git push 미는겁니다!
- git push는 _여러분의_변경을 정한 원격저장소에 업로드하고 그 원격 저장소가 여러분의 새 커밋들을 합치고 갱신하게 합니다. git push가 끝나고 나면, 여러분의 친구들은 원격저장소에서 여러분의 작업을 내려받을수 있게됩니다.
- 여러분은 git push를 작업을 "공개"하는 과정이라고 생각해도 될것입니다. 곧 알아볼 중요한 세부 요소들이 잔뜩 있지만, 일단은 아기 걸음으로 시작해봅시다...
- 노트 -- git push를 매개변수 없이 사용하는 디폴트 행동은 push.default라 불리는 git의 설정에 따라 결정 됩니다. 이 설정의 기본값은 여러분이 사용하는 git 버전에 따라 다릅니다만, 우리 강의에서는 upstream을 값으로 사용합니다. 대단한것은 아니지만, 여러분이 프로젝트를 push하기전에 한번쯤 확인해볼 가치가 있습니다.
```
// 여기 원격저장소에는 없는 변경이 있습니다. 이것들을 업로드 해 봅시다!
git push
// 자 됬습니다 -- 원격 저장소가 커밋 C2를 받았고, 원격 저장소의 브랜치 master가 C2라는 지점까지 갱신 되었습니다. 그리고 원격 저장소의 반영인 우리의 원격 브랜치 (o/master)또한 잘 갱신 되었습니다. 모든게 동기화되어 있습니다!
```

```
// 두개의 새 커밋을 원격 저장소에 공유해봅시다.
git commit
git commit
git push
```

# 1.7 Diverged History

```
git clone
git fakeTeamwork master 1
git commit 
git pull —rebase
git push
```

# 1.8 Locked branch Master

```
git reset --hard o/master
git checkout -b feature C2
git push origin feature
```
